[00:00] Vamos fazer uma revisão do que aprendemos no capítulo. Durante esse capítulo, nós mexemos em duas configurações extras no compilador do TypeScript. Uma é o removeComments. Essa aí significa que todo código de comentário que você escrever no seu arquivo TypeScript, ele não vai aparecer no arquivo compilado.

[00:21] Mas o grande ponto de destaque deste capítulo foi a ativação do StrictNullChecks. Vamos lembrar. Qual é o padrão do TypeScript? É o seguinte. Todo atributo, variável, com propriedade de classe, com variável que você declara, todos eles aceitam o tipo null por padrão.

[00:47] Isso significa que se eu atribuir null aqui, com patrão, sem mexer no compilador TypeScript, ele aceita. Eu consigo atribuir null a esse tipo. Por quê? Porque quando, no TypeScript, lá no tsconfig.json, o padrão é false. Quando é false, eu posso atribuir no para esse tipo. Porque o TypeScript diz que qualquer tipo, no meu sistema, pode receber null.

[01:19] Só que isso pode ser um problema, porque na sua aplicação, você pode ter um valor nulo que você não tratou, e você só vai descobrir o erro em runtime, pode ser um problema.

[01:27] Então, o que a equipe do TypeScript fez? Ela fez o seguinte. Você pode dizer o StrictNullChecks é true. E fazendo isso, você vai ver que o meu código de negociação-controller não vai mais compilar. Por quê? Porque o TypeScript tirou aquela funcionalidade, no qual, qualquer tipo de aplicação, sem que o desenvolvedor defina, pode receber nulo.

[01:52] Então, se eu olho esse tipo, qual é esse tipo? HTMLInput não tem nada dizendo que ele pode receber null. Se eu quiser atribuir null, usamos esse ou | para dizer que esse item pode ser HTMLInput ou null, isto é, HTMLInputElement | null.

[02:08] Esse é o padrão que o TypeScript faz, por debaixo dos panos, quando essa opção está desligada. Ele coloca tipo um type null em todas as variáveis e propriedades de classe que você cria, métodos, e por aí vai.

[02:22] Deixa eu voltar para cá. Vou colocá-lo como true. Vou remover isso aqui. Nós vimos que todo lugar que eu chamar uma API, e essa API pode retornar null, eu vou ter de tratar a minha variável, porque isso pode quebrar o fluxo da minha aplicação.

[02:43] Um exemplo é o querySelector. Quando eu desligo o StrictNullChecks, esse item está dizendo que o querySelector pode HTMLInput ou null. Mas esse item aqui não aceita null.

[03:07] E eu não quero que ele aceite, não faz sentido para mim. Então, o que eu deveria fazer aqui? Eu deveria testar. If, se o valor existe, se não, tento recuperar o estado da minha aplicação. Mas definimos que quando estamos pegando elementos do DOM, nós não vamos fazer a checagem.

[03:23] Vamos silenciar o compilador porque eu estou assumindo a responsabilidade disso. Se você vem do mundo Angular, existe um decorator chamado child ou children, que você também pode silenciar, porque não tem como.

[03:40] Você tem que confiar que aquele valor vai chegar, porque não é você que atribui aquele valor, é o contêiner do ângulo.

[03:46] Então, fizemos isso porque eu estou dizendo que, agora, esse querySelector não vai retornar HTMLInput ou null, ele vai retornar um HTMLInput. Flávio, e se ele retornar ‘null?’. Eu não vou saber. Meu código vai dar problema. Mas eu, como programador, estou assumindo a responsabilidade, fazendo o que chamamos de casting, convertendo um valor, um tipo para outro.

[04:09] Convertendo qual tipo? O tipo HTMLInput, ou null, para HTMLInput, apenas. Ou eu posso usar a outra sintaxe. Estou usando as, e eu digo aqui o tipo que eu quero.

[04:21] Como eu falei no curso, aprenderemos mais sobre Union Types em um próximo módulo. Eu silenciei o StrictNullChecks, e o meu código está funcionando. Mas estudamos também no APP, que no caso do APP, eu não quis silenciar, eu quis tratar.

[04:41] E o TypeScript é inteligente, porque se esse valor pode ser null, e você tem uma condição if, dentro da condição if, você para de ter erros de compilação. Porque o TypeScript é inteligente para saber que essa condição if só vai ser executada se tiver algum valor lá dentro. Já na condição else, não.

[04:58] Então é por isso que se eu tentar usar o form aqui e colocar o edge, ele vai dizer que esse item pode ser possivelmente nulo. E no caso da nossa aplicação, eu quero que lance um erro no console.

[05:10] Então a sacada de quando você vai tratar null ou não, é que você vai tratar o null e vai tentar recuperar sua aplicação de alguma maneira. Colocar um valor para substituir o valor null, ou tentar resolver de outra forma.

[05:25] Ou então, o que você vai fazer, é o seguinte: se não tiver como recuperar sua aplicação, você vai lançar uma exceção para que o desenvolvedor saiba o que está acontecendo por debaixo dos panos enquanto sua aplicação está rodando.

[05:38] Porque nem sempre conseguimos recuperar a nossa aplicação. Por exemplo, aqui não tem nada que eu possa colocar no lugar do form para fazer ele funcionar.

[05:47] Então, precisamos desse jogo de cintura. O StrictNullChecks foi ativado. No próximo módulo, no terceiro curso de JavaScript, que vai ser um pouco mais cheio de técnica, mas um pouco mais puxado, nós já vamos adotar como padrão para evitar ter um código null e chegar em uma situação onde possamos gerar algum tipo de desconforto ou erro dentro do nosso código.

[06:15] Está bom? Chegando no final do curso, eu tenho uma palavrinha para vocês no próximo vídeo.