[00:00] Vamos fazer uma revisão. Nesse capítulo, nós aprendemos que mensagem-view e negociações-view, são duas classes que compartilham bastante código duplicado. E nós tentamos isolar em uma única classe chamada view, a maior quantidade de código que pudéssemos extrair.

[00:22] Primeiro, começamos colocando a propriedade elemento e o construtor, só que nós percebemos que em uma propriedade privada de uma classe pai, não pode ser acessada por classe filhas. Então foi por isso que nós utilizamos o modificador protected.

[00:38] O modificador protected diz que só a própria classe, ou as filhas que herdarem desta classe, podem ter acesso à propriedade protected. Só que isso não foi o suficiente. Quando nós movemos o método update e o template, nós caímos no problema que por mais que o método *update* seja idêntico, o miolo deles seja idêntico, o parâmetro recebido pelo update era diferente em mensagem- view e negociação-view. Um recebia uma string, e outro recebia um modelo de negociações.

[01:13] Quando nós resolvemos isso? Nós tornamos a nossa classe view genérica, passando esse item T aqui. Esse item T vem de type, mas poderia ser D. Contanto que eu coloque D em tudo quanto é lugar, isso aqui vai funcionar também.

[01:33] Aliás, um apelido para você poder acessar. Você pode colocar K também, mas tem que trocar para K. Mas deixa T, porque lembra, remete type, por isso que a galera gosta de usar muito o T e não outra letra.

[01:52] Fizemos isso. Então, agora, o nosso método *update* e template, o parâmetro, que é o model que eles recebem, é do tipo T. Que tipo é esse? Não faço ideia. Quem vai saber é minha filha. Então, se eu olho em mensagem-view, e estendo minha classe view, eu defino qual vai ser o valor de T.

[02:11] Nesse caso, vai ser string; em negociações-view, vai ser negociações. E se eu tentar, na hora em que eu defino esse tipo, se por acaso eu coloco qualquer outra coisa aqui, ele vai me dar um erro de compilação. Porque o template, esse tipo que está aqui, como ele é o tipo T daqui, ele tem que bater, ele tem que ser igual.

[02:33] Então nós conseguimos flexibilizar o nosso seu código. Flávio, por que tanto trabalho de fazer isso?. Porque nós vamos fazer type safety, queremos pegar erro em problema de tempo de compilação, mas, ao mesmo tempo, nós vamos ter que usar desses artifícios para termos um código dinâmico.

[02:48] Porque se fosse em JavaScript puro, é oba-oba; você faz qualquer coisa que você quiser que vai funcionar dinamicamente. E você só vai saber do erro durante o runtime.

[02:57] Em mensagem-view, aprendemos que não faz sentido ter instâncias de view, porque essa view era incompleta, ela tinha um buraco. Que buraco é esse? É o tipo do model.

[03:16] Se você tentar criar uma instância de view, esse item aqui tentar usar um método update, o template, o compilador do TypeScript vai dizer que é do tipo unknown, que ele não sabe o que é. Qual é o tipo? É unknown, que ele não sabe qual é. Qual é o tipo? É Unknown, desconhecido.

[03:31] Tornamos classe view abstrata. Com isso, ninguém pode dar new nessa classe; ela só pode ser usada para ser estendida, eu não posso criar uma instância direto dentro dela. E para forçar com que as filhas implementem um método que ela não sabe antecipadamente como implementar, também tornamos o método em método abstrato.

[04:01] Isso significa que se eu chegar lá em qualquer classe que está se estendendo de view, e eu não implementar o método template, eu vou ter um erro de compilação, me avisando, em tempo de compilação, que eu devo, i must, implementar o método template, e não verificar esse erro durante a runtime.

[04:22] Tudo bem? Então vamos lá para o próximo vídeo, que nós vamos dar uma lapidada no nosso projeto para ele ficar maravilhoso. Vamos lá.